// src/services/asi-service.ts
import { Strategy } from "../types/strategy";

const ASI_API_URL = "https://api.asi1.ai/v1/chat/completions";
const ASI_API_KEY = process.env.NEXT_PUBLIC_ASI_API_KEY;

interface ASIResponse {
  id: string;
  choices: Array<{
    message: {
      role: string;
      content: string;
    };
  }>;
  usage: {
    total_tokens: number;
  };
}

export class ASIService {
  static async generateStrategy(prompt: string): Promise<Strategy | null> {
    try {
      const systemPrompt = `You are AetherFlow AI, an expert DeFi strategist specializing in cross-chain yield optimization. 
      Analyze the user's request and generate a structured cross-chain DeFi strategy.

      RESPONSE FORMAT (JSON only, no other text):
      {
        "name": "Creative strategy name",
        "description": "Detailed description of the strategy",
        "risk": "low|medium|high",
        "estimatedApy": number,
        "chains": ["Ethereum", "Arbitrum", "Optimism", "Polygon", "Base"],
        "protocols": ["Aave", "Compound", "Uniswap", "Curve", "Yearn", "Lido"],
        "strategyType": "bridge|execute|bridge-execute",
        "executionSteps": ["step1", "step2", "step3"],
        "recommendedAmount": number,
        "token": "USDC|ETH|USDT|DAI",
        "contractDetails": {
          "address": "optional contract address if needed",
          "function": "optional function name if needed"
        }
      }

      STRATEGY GUIDELINES:
      - Risk levels: low (1-5% APY), medium (5-15% APY), high (15%+ APY)
      - Prefer established protocols for lower risk
      - Consider gas costs and cross-chain efficiency
      - Include at least 2 chains for cross-chain strategies
      - Suggest realistic APY based on current market conditions

      USER PROMPT: ${prompt}`;

      const response = await fetch(ASI_API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
          Authorization: `Bearer ${ASI_API_KEY}`,
        },
        body: JSON.stringify({
          model: "asi1-mini",
          messages: [
            {
              role: "system",
              content: systemPrompt,
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          temperature: 0.7,
          stream: false,
          max_tokens: 1000,
        }),
      });

      if (!response.ok) {
        throw new Error(`ASI API error: ${response.statusText}`);
      }

      const data: ASIResponse = await response.json();

      if (!data.choices || data.choices.length === 0) {
        throw new Error("No response from AI");
      }

      const content = data.choices[0].message.content;

      // Extract JSON from the response (AI might wrap it in markdown or add text)
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error("Could not parse AI response as JSON");
      }

      const strategyData = JSON.parse(jsonMatch[0]);

      // Convert to our Strategy interface
      return this.parseStrategy(strategyData);
    } catch (error) {
      console.error("ASI Service Error:", error);
      throw error;
    }
  }

  private static parseStrategy(data: any): Strategy {
    // Validate and transform the AI response into our Strategy format
    return {
      id: `custom-${Date.now()}`,
      name: data.name || "AI Generated Strategy",
      description:
        data.description || "Cross-chain DeFi strategy generated by AI",
      risk: this.validateRisk(data.risk),
      apy: this.validateApy(data.estimatedApy),
      chains: this.validateChains(data.chains),
      protocols: this.validateProtocols(data.protocols),
      tvl: 0, // AI doesn't know TVL
      recommended: false,
      type: this.validateStrategyType(data.strategyType),
      executionSteps: data.executionSteps || [],
      recommendedAmount: data.recommendedAmount || 100,
      token: data.token || "USDC",
      contractAddress: data.contractDetails?.address,
      functionName: data.contractDetails?.function,
    };
  }

  private static validateRisk(risk: string): "low" | "medium" | "high" {
    const validRisks = ["low", "medium", "high"];
    return validRisks.includes(risk?.toLowerCase())
      ? (risk.toLowerCase() as any)
      : "medium";
  }

  private static validateApy(apy: number): number {
    return typeof apy === "number" && apy > 0 && apy < 1000 ? apy : 8.5;
  }

  private static validateChains(chains: string[]): string[] {
    const validChains = [
      "Ethereum",
      "Arbitrum",
      "Optimism",
      "Polygon",
      "Base",
      "Avalanche",
      "Fantom",
    ];
    return Array.isArray(chains)
      ? chains.filter((chain) => validChains.includes(chain)).slice(0, 4)
      : ["Ethereum", "Arbitrum"];
  }

  private static validateProtocols(protocols: string[]): string[] {
    const validProtocols = [
      "Aave",
      "Compound",
      "Uniswap",
      "Curve",
      "Yearn",
      "Lido",
      "Maker",
      "Balancer",
    ];
    return Array.isArray(protocols)
      ? protocols
          .filter((protocol) => validProtocols.includes(protocol))
          .slice(0, 3)
      : ["Aave", "Uniswap"];
  }

  private static validateStrategyType(
    type: string
  ): "bridge" | "execute" | "bridge-execute" {
    const validTypes = ["bridge", "execute", "bridge-execute"];
    return validTypes.includes(type) ? (type as any) : "bridge";
  }
}
